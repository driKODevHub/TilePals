using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

/// <summary>
/// Editor Window tool to bulk update or clear visual representations generated by BuildingsVisualGenerator
/// across multiple prefab assets. It allows applying a specific DorfromantikLikeGeneratorStrategySO as a "strategy cartridge"
/// for the generation process.
/// </summary>
public class BulkBuildingsVisualUpdater : EditorWindow
{
    /// <summary>
    /// List of prefab assets whose visuals will be updated or cleared.
    /// These should be GameObjects that have a BuildingsVisualGenerator component.
    /// </summary>
    public List<GameObject> targetPrefabs = new List<GameObject>();

    /// <summary>
    /// The DorfromantikLikeGeneratorStrategySO asset to be used as a "strategy cartridge" for generating visuals.
    /// This will be assigned to the GenerationStrategy property of the BuildingsVisualGenerator component.
    /// </summary>
    public DorfromantikLikeGeneratorStrategySO strategyCartridge;

    /// <summary>
    /// Opens the Bulk Buildings Visual Updater window from the Unity Editor's Tools menu.
    /// </summary>
    [MenuItem("Tools/Bulk Buildings Visual Updater")]
    public static void ShowWindow()
    {
        GetWindow<BulkBuildingsVisualUpdater>("Bulk Visual Updater");
    }

    /// <summary>
    /// Draws the GUI for the editor window.
    /// </summary>
    private void OnGUI()
    {
        GUILayout.Label("Bulk Buildings Visual Update Tool", EditorStyles.boldLabel);

        // Field for assigning the strategyCartridge (DorfromantikLikeGeneratorStrategySO)
        strategyCartridge = (DorfromantikLikeGeneratorStrategySO)EditorGUILayout.ObjectField(
            "Strategy Cartridge (DorfromantikLikeGeneratorStrategySO)",
            strategyCartridge,
            typeof(DorfromantikLikeGeneratorStrategySO),
            false // Не є об'єктом сцени, це має бути ассет
        );

        // Display and manage the list of target prefabs.
        EditorGUILayout.Space();
        EditorGUILayout.LabelField("Target Prefabs (Drag GameObjects here):", EditorStyles.boldLabel);

        // Використовуємо SerializedObject та SerializedProperty для коректної роботи зі списком в Editor GUI.
        SerializedObject serialObj = new SerializedObject(this);
        SerializedProperty serialProperty = serialObj.FindProperty("targetPrefabs");

        // Малюємо поле властивості для списку, дозволяючи перетягування та зміну розміру.
        EditorGUILayout.PropertyField(serialProperty, true); // 'true' робить його розширюваним
        serialObj.ApplyModifiedProperties(); // Застосовуємо зміни, зроблені в інспекторі, до фактичного списку.

        EditorGUILayout.Space();

        // Кнопка для запуску генерації візуалу для всіх вибраних префабів.
        if (GUILayout.Button("Generate Visuals for Selected Prefabs"))
        {
            GenerateVisualsForAll();
        }

        // Кнопка для запуску очищення візуалу для всіх вибраних префабів.
        if (GUILayout.Button("Clear Visuals for Selected Prefabs"))
        {
            ClearVisualsForAll();
        }
    }

    /// <summary>
    /// Ітерує список цільових префабів і генерує візуал для кожного.
    /// Визначений strategyCartridge призначається властивості GenerationStrategy
    /// компонента BuildingsVisualGenerator кожного префабу.
    /// </summary>
    private void GenerateVisualsForAll()
    {
        if (strategyCartridge == null)
        {
            Debug.LogError("Strategy Cartridge (DorfromantikLikeGeneratorStrategySO) is not assigned. Please assign it in the window.");
            return;
        }

        if (targetPrefabs == null || targetPrefabs.Count == 0)
        {
            Debug.LogWarning("No prefabs assigned to update. Please drag GameObjects into the 'Target Prefabs' list.");
            return;
        }

        // Ітеруємо кожен префаб у списку.
        foreach (GameObject prefabAsset in targetPrefabs)
        {
            if (prefabAsset == null)
            {
                Debug.LogWarning("Skipping null entry in Target Prefabs list.");
                continue;
            }

            // Отримуємо шлях до ассета, щоб завантажити його вміст.
            string assetPath = AssetDatabase.GetAssetPath(prefabAsset);
            if (string.IsNullOrEmpty(assetPath) || !AssetDatabase.Contains(prefabAsset))
            {
                Debug.LogWarning($"Skipping '{prefabAsset.name}': Not a valid prefab asset (e.g., it might be a scene object). Only prefab assets are supported.");
                continue;
            }

            // Завантажуємо вміст префабу для модифікації без його інстанціювання у сцені.
            GameObject prefabRoot = PrefabUtility.LoadPrefabContents(assetPath);

            // Отримуємо компонент BuildingsVisualGenerator з завантаженого вмісту префабу.
            BuildingsVisualGenerator generator = prefabRoot.GetComponent<BuildingsVisualGenerator>();
            if (generator == null)
            {
                Debug.LogWarning($"Prefab '{prefabAsset.name}' does not have a BuildingsVisualGenerator component. Skipping.");
                PrefabUtility.UnloadPrefabContents(prefabRoot); // Завжди вивантажуємо вміст, якщо завантажено.
                continue;
            }

            // Призначаємо вибраний стратегічний картридж властивості GenerationStrategy.
            // Згідно з BuildingsVisualGenerator.cs, це автоматично запустить GenerateGridVisual().
            generator.GenerationStrategy = strategyCartridge;
            // Позначаємо компонент як змінений, щоб Unity знав про зміну та зберіг її.
            EditorUtility.SetDirty(generator);

            // Зберігаємо змінений вміст префабу назад в ассет.
            PrefabUtility.SaveAsPrefabAsset(prefabRoot, assetPath);
            PrefabUtility.UnloadPrefabContents(prefabRoot); // Вивантажуємо тимчасовий вміст.

            Debug.Log($"Generated visual for prefab: {prefabAsset.name}");
        }

        // Зберігаємо всі незавершені зміни ассетів і оновлюємо базу даних ассетів, щоб відобразити зміни у вікні Project.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
        Debug.Log("Bulk visual generation complete.");
    }

    /// <summary>
    /// Ітерує список цільових префабів і очищає їхній згенерований візуал.
    /// </summary>
    private void ClearVisualsForAll()
    {
        if (targetPrefabs == null || targetPrefabs.Count == 0)
        {
            Debug.LogWarning("No prefabs assigned to clear visuals from. Please drag GameObjects into the 'Target Prefabs' list.");
            return;
        }

        // Ітеруємо кожен префаб у списку.
        foreach (GameObject prefabAsset in targetPrefabs)
        {
            if (prefabAsset == null)
            {
                Debug.LogWarning("Skipping null entry in Target Prefabs list.");
                continue;
            }

            string assetPath = AssetDatabase.GetAssetPath(prefabAsset);
            if (string.IsNullOrEmpty(assetPath) || !AssetDatabase.Contains(prefabAsset))
            {
                Debug.LogWarning($"Skipping '{prefabAsset.name}': Not a valid prefab asset. Only prefab assets are supported.");
                continue;
            }

            // Завантажуємо вміст префабу для модифікації.
            GameObject prefabRoot = PrefabUtility.LoadPrefabContents(assetPath);
            BuildingsVisualGenerator generator = prefabRoot.GetComponent<BuildingsVisualGenerator>();

            if (generator == null)
            {
                Debug.LogWarning($"Prefab '{prefabAsset.name}' does not have a BuildingsVisualGenerator component. Skipping.");
                PrefabUtility.UnloadPrefabContents(prefabRoot);
                continue;
            }

            // Викликаємо метод очищення візуалу на компоненті префабу.
            generator.ClearGeneratedVisual();

            // Зберігаємо змінений вміст префабу назад в ассет.
            PrefabUtility.SaveAsPrefabAsset(prefabRoot, assetPath);
            PrefabUtility.UnloadPrefabContents(prefabRoot);

            Debug.Log($"Cleared visual for prefab: {prefabAsset.name}");
        }

        // Зберігаємо всі незавершені зміни ассетів і оновлюємо базу даних ассетів.
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
        Debug.Log("Bulk visual clearing complete.");
    }
}